{% extends "base.html" %}

{% block title %}Tasks - Mina{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/tasks.css') }}?v=5">
{% endblock %}

{% block content %}
<div class="container tasks-container">
    <!-- Header -->
    <div class="tasks-header flex justify-between items-center">
        <div>
            <h1 class="tasks-title">Action Items</h1>
            <p class="tasks-subtitle">Track and manage tasks from your meetings</p>
        </div>
        <div class="header-actions">
            <button class="btn btn-secondary btn-generate-proposals" data-meeting-id="{{ meeting_id if meeting_id else '' }}">
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                </svg>
                AI Proposals
            </button>
            <button class="btn btn-primary">
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                </svg>
                New Task
            </button>
        </div>
    </div>

    <!-- Offline/Status Banner -->
    <div id="connection-banner" class="connection-banner hidden">
        <span class="connection-status-icon"></span>
        <span class="connection-message"></span>
        <span class="pending-count"></span>
    </div>

    <!-- Filters -->
    <div class="task-filters">
        <button class="filter-tab active" data-filter="all">
            All Tasks
            <span class="filter-counter filter-counter-all" data-counter="all">
                {{ tasks|length if tasks else 0 }}
            </span>
        </button>
        <button class="filter-tab" data-filter="pending">
            Pending
            <span class="filter-counter filter-counter-pending" data-counter="pending">
                {{ tasks|selectattr('completed', 'equalto', false)|list|length if tasks else 0 }}
            </span>
        </button>
        <button class="filter-tab" data-filter="completed">
            Completed
            <span class="filter-counter filter-counter-completed" data-counter="completed">
                {{ tasks|selectattr('completed', 'equalto', true)|list|length if tasks else 0 }}
            </span>
        </button>
    </div>

    <!-- Bulk Action Toolbar (appears when tasks selected) -->
    <div id="bulk-action-toolbar" class="bulk-action-toolbar hidden">
        <div class="bulk-action-info">
            <span id="bulk-selected-count">0</span> tasks selected
        </div>
        <div class="bulk-action-buttons">
            <button class="bulk-action-btn" id="bulk-complete-btn">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                </svg>
                Complete
            </button>
            <button class="bulk-action-btn" id="bulk-delete-btn">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
                Delete
            </button>
            <button class="bulk-action-btn" id="bulk-label-btn">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"/>
                </svg>
                Add Label
            </button>
            <button class="bulk-action-btn bulk-action-btn-cancel" id="bulk-cancel-btn">
                Cancel
            </button>
        </div>
    </div>

    <!-- Search & Sort Toolbar (CROWN‚Å¥.5 Task 5) -->
    <div class="search-sort-toolbar">
        <div class="search-wrapper">
            <svg class="search-icon" width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
            </svg>
            <input type="text" 
                   id="task-search-input" 
                   class="search-input" 
                   placeholder="Search tasks..."
                   autocomplete="off"
                   aria-label="Search tasks">
            <button id="search-clear-btn" class="search-clear-btn hidden" aria-label="Clear search">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        <div class="sort-wrapper">
            <svg class="sort-icon" width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12"/>
            </svg>
            <select id="task-sort-select" class="sort-select" aria-label="Sort tasks">
                <option value="default">Sort: Default</option>
                <option value="priority">Sort: Priority (High ‚Üí Low)</option>
                <option value="priority-reverse">Sort: Priority (Low ‚Üí High)</option>
                <option value="due-date">Sort: Due Date (Soonest first)</option>
                <option value="due-date-reverse">Sort: Due Date (Latest first)</option>
                <option value="created">Sort: Created (Newest first)</option>
                <option value="created-reverse">Sort: Created (Oldest first)</option>
                <option value="title">Sort: Title (A ‚Üí Z)</option>
                <option value="title-reverse">Sort: Title (Z ‚Üí A)</option>
            </select>
        </div>
        <div class="toolbar-stats">
            <span id="visible-task-count">{{ tasks|length if tasks else 0 }}</span>
            <span class="stats-label">of</span>
            <span id="total-task-count">{{ tasks|length if tasks else 0 }}</span>
            <span class="stats-label">tasks</span>
        </div>
    </div>

    <!-- AI Proposals Section (CROWN‚Å¥.5 Task 10) -->
    <div id="ai-proposals-container"></div>

    <!-- Task List Container (CROWN‚Å¥.5 Required Structure) -->
    <div id="tasks-list-container" class="tasks-list-container">
        {% if tasks and tasks|length > 0 %}
            {% for task in tasks %}
            <div class="task-card{% if task.completed %} completed{% endif %}" 
                 data-task-id="{{ task.id }}"
                 data-status="{% if task.completed %}completed{% else %}pending{% endif %}"
                 data-priority="{{ task.priority|default('medium')|lower }}"
                 data-assigned-to="{{ task.assigned_to_id or '' }}"
                 data-due-date="{{ task.due_date or '' }}"
                 data-labels="{{ task.labels|tojson|escape if task.labels else '[]' }}">
                <div class="checkbox-wrapper">
                    <input type="checkbox" {% if task.completed %}checked{% endif %} class="task-checkbox" data-task-id="{{ task.id }}">
                </div>
                <div class="task-content">
                    <h3 class="task-title">{{ task.title or 'Untitled Task' }}</h3>
                    <div class="task-metadata">
                        <span class="task-assignee" data-field="assignee" title="Click to assign">
                            {% if task.assigned_to %}
                                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                                {{ task.assigned_to.display_name or task.assigned_to.username }}
                            {% else %}
                                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                                Unassigned
                            {% endif %}
                        </span>
                        <span class="task-due-date" data-field="due_date" title="Click to set due date">
                            {% if task.due_date %}
                                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>
                                {{ task.due_date.strftime('%b %d') }}
                            {% else %}
                                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>
                                No due date
                            {% endif %}
                        </span>
                        {% if task.labels and task.labels|length > 0 %}
                            <div class="task-labels" data-field="labels" title="Click to edit labels">
                                {% for label in task.labels %}
                                    <span class="task-label">{{ label }}</span>
                                {% endfor %}
                            </div>
                        {% else %}
                            <span class="task-labels-empty" data-field="labels" title="Click to add labels">
                                <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/></svg>
                                Add labels
                            </span>
                        {% endif %}
                    </div>
                </div>
                <div class="task-actions">
                    <span class="priority-badge priority-{{ task.priority|default('medium')|lower }}">
                        {{ task.priority|default('medium') }}
                    </span>
                    <button class="task-menu-trigger" 
                            data-task-id="{{ task.id }}"
                            role="button"
                            aria-haspopup="menu"
                            aria-expanded="false"
                            aria-label="Task actions menu"
                            title="More actions">
                        <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                            <circle cx="12" cy="5" r="2"/>
                            <circle cx="12" cy="12" r="2"/>
                            <circle cx="12" cy="19" r="2"/>
                        </svg>
                    </button>
                </div>
            </div>
            {% endfor %}
        {% endif %}
    </div>

    <!-- Empty State (CROWN‚Å¥.5 Required ID) -->
    <div id="tasks-empty-state" class="empty-state{% if tasks and tasks|length > 0 %} hidden{% endif %}">
        <svg class="empty-state-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"/>
        </svg>
        <h3 class="text-xl font-semibold mb-2">No tasks yet</h3>
        <p class="text-secondary mb-6">Tasks from your meetings will appear here</p>
        <button class="btn btn-primary" id="empty-state-create-btn">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
            </svg>
            Create your first task
        </button>
    </div>

    <!-- Loading State (CROWN‚Å¥.5 Skeleton Loaders) -->
    <div id="tasks-loading-state" class="tasks-loading-state hidden">
        <div class="task-skeleton">
            <div class="skeleton-checkbox"></div>
            <div class="skeleton-content">
                <div class="skeleton-title"></div>
                <div class="skeleton-meta"></div>
            </div>
        </div>
        <div class="task-skeleton">
            <div class="skeleton-checkbox"></div>
            <div class="skeleton-content">
                <div class="skeleton-title skeleton-width-random"></div>
                <div class="skeleton-meta skeleton-width-random"></div>
            </div>
        </div>
        <div class="task-skeleton">
            <div class="skeleton-checkbox"></div>
            <div class="skeleton-content">
                <div class="skeleton-title skeleton-width-random"></div>
                <div class="skeleton-meta skeleton-width-random"></div>
            </div>
        </div>
        <div class="task-skeleton">
            <div class="skeleton-checkbox"></div>
            <div class="skeleton-content">
                <div class="skeleton-title skeleton-width-random"></div>
                <div class="skeleton-meta skeleton-width-random"></div>
            </div>
        </div>
        <div class="task-skeleton">
            <div class="skeleton-checkbox"></div>
            <div class="skeleton-content">
                <div class="skeleton-title skeleton-width-random"></div>
                <div class="skeleton-meta skeleton-width-random"></div>
            </div>
        </div>
    </div>

    <!-- Error State (CROWN‚Å¥.5) -->
    <div id="tasks-error-state" class="tasks-error-state hidden">
        <svg class="error-state-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
        </svg>
        <h3 class="error-state-title">Unable to load tasks</h3>
        <p class="error-state-message">We couldn't fetch your tasks. Please check your connection and try again.</p>
        <div class="error-state-actions">
            <button class="btn btn-primary" id="error-state-retry-btn">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                </svg>
                Retry
            </button>
            <button class="btn btn-secondary" id="error-state-clear-cache-btn">
                Clear Cache
            </button>
        </div>
    </div>
</div>

<!-- Task Creation Modal (Crown+ Glassmorphism) -->
<div id="task-modal-overlay" class="task-modal-overlay hidden">
    <div class="task-modal">
        <div class="task-modal-header">
            <h2 class="task-modal-title">Create New Task</h2>
            <button class="task-modal-close" id="task-modal-close">
                <svg width="24" height="24" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <form id="task-create-form">
            <!-- Title (Required) -->
            <div class="task-form-group">
                <label class="task-form-label required" for="task-title">Task Title</label>
                <input 
                    type="text" 
                    id="task-title" 
                    class="task-form-input" 
                    placeholder="What needs to be done?"
                    required
                    autocomplete="off"
                >
            </div>
            
            <!-- Description (Optional) -->
            <div class="task-form-group">
                <label class="task-form-label" for="task-description">Description</label>
                <textarea 
                    id="task-description" 
                    class="task-form-textarea" 
                    placeholder="Add more details..."
                ></textarea>
            </div>
            
            <!-- AI Prediction Suggestions (CROWN‚Å¥.5) -->
            <div id="ai-prediction-banner" class="ai-prediction-banner hidden">
                <div class="ai-prediction-banner-header">
                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
                    </svg>
                    <strong class="ai-prediction-title">AI Suggestions</strong>
                </div>
                <div id="ai-prediction-content" class="ai-prediction-content">
                    <!-- Predictions will be rendered here -->
                </div>
            </div>
            
            <!-- Priority -->
            <div class="task-form-group">
                <label class="task-form-label" for="task-priority">Priority</label>
                <select id="task-priority" class="task-form-select">
                    <option value="low">Low</option>
                    <option value="medium" selected>Medium</option>
                    <option value="high">High</option>
                    <option value="urgent">Urgent</option>
                </select>
            </div>
            
            <!-- Due Date (Optional) -->
            <div class="task-form-group">
                <label class="task-form-label" for="task-due-date">Due Date</label>
                <input 
                    type="date" 
                    id="task-due-date" 
                    class="task-form-input"
                >
            </div>
            
            <!-- Assignee (Optional) -->
            <div class="task-form-group">
                <label class="task-form-label" for="task-assignee">Assignee</label>
                <input 
                    type="text" 
                    id="task-assignee" 
                    class="task-form-input" 
                    placeholder="Who's responsible?"
                    autocomplete="off"
                >
            </div>
            
            <!-- Actions -->
            <div class="task-form-actions">
                <button type="button" class="task-form-btn task-form-btn-cancel" id="task-form-cancel">
                    Cancel
                </button>
                <button type="submit" class="task-form-btn task-form-btn-create" id="task-form-submit">
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display: inline-block; margin-right: 8px;">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                    </svg>
                    Create Task
                </button>
            </div>
        </form>
    </div>
</div>

<!-- Reusable Task Menu (Glassmorphic Dropdown) -->
<div id="task-menu" class="task-menu" role="menu" data-state="closed">
    <button class="task-menu-item" data-action="view-details" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
        </svg>
        <span>View details</span>
    </button>
    
    <div class="task-menu-divider"></div>
    
    <button class="task-menu-item" data-action="edit" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
        </svg>
        <span>Edit title</span>
    </button>
    
    <button class="task-menu-item" data-action="toggle-status" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
        </svg>
        <span>Mark complete</span>
    </button>
    
    <button class="task-menu-item" data-action="priority" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18"/>
        </svg>
        <span>Change priority</span>
    </button>
    
    <button class="task-menu-item" data-action="due-date" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
        </svg>
        <span>Set due date</span>
    </button>
    
    <button class="task-menu-item" data-action="assign" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
        </svg>
        <span>Assign to...</span>
    </button>
    
    <button class="task-menu-item" data-action="labels" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"/>
        </svg>
        <span>Edit labels</span>
    </button>
    
    <button class="task-menu-item" data-action="jump-to-transcript" role="menuitem" class="hidden">
        <svg fill="currentColor" viewBox="0 0 24 24">
            <path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5z"/>
        </svg>
        <span>Jump to transcript</span>
    </button>
    
    <div class="task-menu-divider"></div>
    
    <button class="task-menu-item" data-action="archive" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"/>
        </svg>
        <span>Archive</span>
    </button>
    
    <button class="task-menu-item destructive" data-action="delete" role="menuitem">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
        <span>Delete</span>
    </button>
</div>

<!-- Snooze Duration Picker Modal -->
<div id="snooze-modal-overlay" class="task-modal-overlay hidden">
    <div class="task-modal task-modal-small">
        <div class="task-modal-header">
            <h2 class="task-modal-title">Snooze Task</h2>
            <button class="task-modal-close" id="snooze-modal-close">
                <svg width="24" height="24" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <div class="modal-body">
            <p class="text-secondary mb-4" id="snooze-task-title">Snooze this task until...</p>
            
            <div class="snooze-options">
                <button class="snooze-option-btn" data-duration="1h">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <span>1 Hour</span>
                </button>
                <button class="snooze-option-btn" data-duration="4h">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <span>4 Hours</span>
                </button>
                <button class="snooze-option-btn" data-duration="tomorrow">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                    </svg>
                    <span>Tomorrow</span>
                </button>
                <button class="snooze-option-btn" data-duration="1w">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                    </svg>
                    <span>1 Week</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Merge Task Selector Modal -->
<div id="merge-modal-overlay" class="task-modal-overlay hidden">
    <div class="task-modal task-modal-medium">
        <div class="task-modal-header">
            <h2 class="task-modal-title">Merge Tasks</h2>
            <button class="task-modal-close" id="merge-modal-close">
                <svg width="24" height="24" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <div class="modal-body">
            <p class="text-secondary mb-4" id="merge-task-title">Select a task to merge with:</p>
            
            <div id="merge-task-list" class="merge-task-list">
                <!-- Task options will be populated dynamically -->
            </div>
            
            <div class="mt-6 text-sm text-secondary">
                <p><strong>Note:</strong> The selected task will be merged into the current task. All labels, dates, and metadata will be combined.</p>
            </div>
        </div>
    </div>
</div>

<!-- Task Detail Modal (CROWN‚Å¥.5 Task 7) -->
<div id="task-detail-modal-overlay" class="task-modal-overlay hidden">
    <div class="task-modal task-modal-large">
        <div class="task-modal-header">
            <h2 class="task-modal-title" id="task-detail-title">Task Details</h2>
            <button class="task-modal-close" id="task-detail-close">
                <svg width="24" height="24" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <!-- Tab Navigation -->
        <div class="task-detail-tabs">
            <button class="task-detail-tab active" data-tab="details">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                </svg>
                Details
            </button>
            <button class="task-detail-tab" data-tab="comments">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
                </svg>
                Comments <span class="tab-badge" id="comments-count">0</span>
            </button>
            <button class="task-detail-tab" data-tab="history">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                History
            </button>
            <button class="task-detail-tab" data-tab="attachments">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
                </svg>
                Attachments <span class="tab-badge" id="attachments-count">0</span>
            </button>
        </div>
        
        <div class="modal-body task-detail-body">
            <!-- Details Tab -->
            <div class="task-detail-panel active" data-panel="details">
                <div class="task-detail-section">
                    <label class="task-detail-label">Title</label>
                    <div class="task-detail-value editable" id="detail-title" contenteditable="false">
                        <!-- Title will be populated -->
                    </div>
                </div>
                
                <div class="task-detail-row">
                    <div class="task-detail-section">
                        <label class="task-detail-label">Status</label>
                        <select class="task-detail-select" id="detail-status">
                            <option value="pending">Pending</option>
                            <option value="in_progress">In Progress</option>
                            <option value="completed">Completed</option>
                        </select>
                    </div>
                    
                    <div class="task-detail-section">
                        <label class="task-detail-label">Priority</label>
                        <select class="task-detail-select" id="detail-priority">
                            <option value="low">Low</option>
                            <option value="medium">Medium</option>
                            <option value="high">High</option>
                        </select>
                    </div>
                </div>
                
                <div class="task-detail-row">
                    <div class="task-detail-section">
                        <label class="task-detail-label">Due Date</label>
                        <input type="date" class="task-detail-input" id="detail-due-date">
                    </div>
                    
                    <div class="task-detail-section">
                        <label class="task-detail-label">Created</label>
                        <div class="task-detail-value" id="detail-created">
                            <!-- Created date -->
                        </div>
                    </div>
                </div>
                
                <div class="task-detail-section">
                    <label class="task-detail-label">Assigned To</label>
                    <div class="task-assignees" id="detail-assignees">
                        <!-- Assignees will be populated -->
                    </div>
                </div>
                
                <div class="task-detail-section">
                    <label class="task-detail-label">Description</label>
                    <textarea class="task-detail-textarea" id="detail-description" placeholder="Add a description..." rows="4"></textarea>
                </div>
                
                <div class="task-detail-section">
                    <label class="task-detail-label">Source</label>
                    <div class="task-detail-value" id="detail-source">
                        <!-- Source info (AI/Manual) -->
                    </div>
                </div>
            </div>
            
            <!-- Comments Tab -->
            <div class="task-detail-panel" data-panel="comments">
                <div class="comments-list" id="comments-list">
                    <!-- Comments will be populated -->
                </div>
                
                <div class="comment-composer">
                    <textarea class="comment-input" id="comment-input" placeholder="Add a comment..." rows="3"></textarea>
                    <div class="comment-actions">
                        <button class="btn-secondary modal-btn" id="cancel-comment">Cancel</button>
                        <button class="btn-primary modal-btn" id="add-comment">Comment</button>
                    </div>
                </div>
            </div>
            
            <!-- History Tab -->
            <div class="task-detail-panel" data-panel="history">
                <div class="history-timeline" id="history-timeline">
                    <!-- History events will be populated -->
                </div>
            </div>
            
            <!-- Attachments Tab -->
            <div class="task-detail-panel" data-panel="attachments">
                <div class="attachments-empty" id="attachments-empty">
                    <svg width="48" height="48" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
                    </svg>
                    <p>No attachments yet</p>
                    <p class="text-secondary">Attachments feature coming soon</p>
                </div>
                <div class="attachments-list hidden" id="attachments-list">
                    <!-- Attachments will be populated -->
                </div>
            </div>
        </div>
        
        <div class="modal-footer">
            <button class="btn-secondary modal-btn" id="task-detail-cancel">Close</button>
            <button class="btn-primary modal-btn" id="task-detail-save">Save Changes</button>
        </div>
    </div>
</div>

<!-- CROWN‚Å¥.5 Frontend Modules (crown-telemetry and websocket-manager loaded in base.html) -->
<script src="{{ url_for('static', filename='js/quiet-state-manager.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/emotional-animations.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-cache.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-search-sort.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/quick-actions-bar.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-detail-modal.js') }}" nonce="{{ g.csp_nonce }}"></script>
<!-- CROWN‚Å¥.5 Phase 1.7: PrefetchController with Task Adapter -->
<script src="{{ url_for('static', filename='js/prefetch-controller.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-prefetch-adapter.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-bootstrap.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-merge-ui.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-optimistic-ui.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-inline-editing.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-actions-menu.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-bulk-operations.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-drag-drop.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-proposal-ui.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-offline-queue.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-multi-tab-sync.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-idle-sync.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/predictive-engine.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/cognitive-synchronizer.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-websocket-handlers.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-virtual-list.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-clustering.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/haptic-feedback.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/performance-validator.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-keyboard-shortcuts.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/reconciliation-cycle.js') }}" nonce="{{ g.csp_nonce }}"></script>

<!-- CROWN‚Å¥.5 Phase 2: Cache-First Architecture -->
<script src="{{ url_for('static', filename='js/indexeddb-cache.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/task-store.js') }}" nonce="{{ g.csp_nonce }}"></script>
<script src="{{ url_for('static', filename='js/temporal-recovery-engine.js') }}" nonce="{{ g.csp_nonce }}"></script>

<script nonce="{{ g.csp_nonce }}">
/**
 * CROWN‚Å¥.5 Tasks Page Initialization
 * Integrates all frontend modules for enterprise-grade task management
 */
(async function() {
    'use strict';
    
    // Set user context for WebSocket authentication and CROWN‚Å¥.5 modules
    window.CURRENT_USER_ID = {{ current_user.id if current_user.is_authenticated else 'null' }};
    window.WORKSPACE_ID = {{ current_user.workspace_id if current_user.workspace_id else 'null' }};
    window.CURRENT_SESSION_ID = null;
    
    console.log('üöÄ Initializing CROWN‚Å¥.5 Tasks Page (Phase 2)...');
    
    // CROWN Telemetry is auto-initialized by crown-telemetry.js
    // Just verify it's available
    if (window.CROWNTelemetry) {
        window.crownTelemetry = window.CROWNTelemetry;
        console.log('üìä CROWN Telemetry ready');
    } else {
        console.warn('‚ö†Ô∏è CROWNTelemetry not available');
    }
    
    // CRITICAL: Register task handlers BEFORE connecting to ensure listeners attach
    if (window.tasksWS && window.wsManager) {
        window.tasksWS.init();
        console.log('‚úÖ Task handlers registered (before connection)');
    } else {
        console.warn('‚ö†Ô∏è Task handlers or WebSocket Manager not available');
    }
    
    // Initialize WebSocket Manager (connects to tasks namespace)
    if (window.wsManager) {
        const workspaceId = window.WORKSPACE_ID || 1;
        await window.wsManager.init(workspaceId, ['tasks']);
        console.log('üîå WebSocket Manager initialized for workspace', workspaceId);
    } else {
        console.warn('‚ö†Ô∏è WebSocket Manager not available');
    }
    
    // Wait for all modules to load (with 5-second timeout)
    const waitForModules = () => {
        return new Promise((resolve) => {
            const startTime = Date.now();
            const timeout = 5000; // 5 seconds max wait
            
            const check = () => {
                // CROWN‚Å¥.5: Core required modules (must load)
                const coreModulesLoaded = window.taskCache && window.taskBootstrap && window.optimisticUI && 
                    window.offlineQueue && window.multiTabSync && window.idleSyncService && 
                    window.predictiveEngine && window.tasksWS && window.taskVirtualList && 
                    window.taskShortcuts && window.TaskInlineEditing && window.TaskActionsMenu;
                
                // CROWN‚Å¥.5: Optional modules (nice-to-have, but not blocking)
                const optionalModulesLoaded = window.TaskBulkOperations && window.TaskDragDrop;
                
                if (coreModulesLoaded) {
                    if (!optionalModulesLoaded) {
                        console.warn('‚ö†Ô∏è Some optional modules not loaded (bulk operations, drag-drop)');
                    }
                    resolve(true);
                } else if (Date.now() - startTime > timeout) {
                    console.warn('‚ö†Ô∏è Module loading timeout - proceeding with available modules');
                    console.warn('Missing core modules:', {
                        taskCache: !!window.taskCache,
                        taskBootstrap: !!window.taskBootstrap,
                        optimisticUI: !!window.optimisticUI,
                        offlineQueue: !!window.offlineQueue,
                        multiTabSync: !!window.multiTabSync,
                        idleSyncService: !!window.idleSyncService,
                        predictiveEngine: !!window.predictiveEngine,
                        tasksWS: !!window.tasksWS,
                        taskVirtualList: !!window.taskVirtualList,
                        taskShortcuts: !!window.taskShortcuts,
                        TaskInlineEditing: !!window.TaskInlineEditing,
                        TaskActionsMenu: !!window.TaskActionsMenu
                    });
                    console.info('Optional modules:', {
                        TaskBulkOperations: !!window.TaskBulkOperations,
                        TaskDragDrop: !!window.TaskDragDrop
                    });
                    resolve(false);
                } else {
                    setTimeout(check, 50);
                }
            };
            check();
        });
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CRITICAL: Setup basic UI FIRST (before waiting for advanced modules)
    // This ensures filter tabs and modals work even if advanced features fail
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Filter Tabs Setup (All / Pending / Completed)
    function setupFilterTabs() {
        document.querySelectorAll('.filter-tab').forEach(tab => {
            tab.addEventListener('click', async () => {
                if (tab.classList.contains('cluster-toggle')) {
                    return;
                }
                
                const filter = tab.dataset.filter;
                console.log(`üîç Filter changed to: ${filter}`);
                
                // Update active tab visual state
                document.querySelectorAll('.filter-tab').forEach(t => {
                    if (!t.classList.contains('cluster-toggle')) {
                        t.classList.remove('active');
                    }
                });
                tab.classList.add('active');
                
                // Dispatch event for search/sort module
                document.dispatchEvent(new CustomEvent('filterChanged', {
                    detail: { filter }
                }));
                
                // Update viewState in cache if available
                if (window.taskCache) {
                    await window.taskCache.setViewState('tasks_page', { activeFilter: filter });
                }
                
                // If clustering is enabled, exit cluster mode
                if (window.taskClusteringManager && window.taskClusteringManager.enabled) {
                    console.log('üìã Exiting clustering mode (switching to filter view)');
                    await window.taskClusteringManager.showNormalView();
                    return;
                }
                
                // Fetch filtered tasks from cache if available
                if (!window.taskCache) {
                    console.warn('‚ö†Ô∏è TaskCache not available - filter tabs disabled');
                    return;
                }
                
                const allTasks = await window.taskCache.getAllTasks();
                let filteredTasks = allTasks;
                
                if (filter === 'pending') {
                    filteredTasks = allTasks.filter(t => t.status === 'todo' || t.status === 'in_progress');
                } else if (filter === 'completed') {
                    filteredTasks = allTasks.filter(t => t.status === 'completed' || t.status === 'done');
                }
                
                console.log(`üìä Rendering ${filteredTasks.length} of ${allTasks.length} tasks (filter: ${filter})`);
                
                // Re-render with filtered tasks using TaskBootstrap
                if (window.taskBootstrap) {
                    await window.taskBootstrap.renderTasks(filteredTasks);
                    await window.taskBootstrap.updateCounters(filteredTasks);
                }
            });
        });
        
        console.log('üîç Filter tabs initialized');
    }
    
    // Modal elements
    const modalOverlay = document.getElementById('task-modal-overlay');
    const modalClose = document.getElementById('task-modal-close');
    const modalCancel = document.getElementById('task-form-cancel');
    const taskForm = document.getElementById('task-create-form');
    
    // Open modal function
    function openTaskModal() {
        if (modalOverlay) {
            modalOverlay.classList.remove('hidden');
            modalOverlay.classList.add('active');
            const titleInput = document.getElementById('task-title');
            if (titleInput) titleInput.focus();
            if (taskForm) taskForm.reset();
        }
    }
    
    // Close modal function
    function closeTaskModal() {
        if (modalOverlay) {
            modalOverlay.classList.remove('active');
            modalOverlay.classList.add('hidden');
        }
    }
    
    // Setup task creation buttons
    const createButtons = document.querySelectorAll('.btn-primary');
    createButtons.forEach(btn => {
        if (btn.textContent.includes('New Task') || btn.textContent.includes('Create')) {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                openTaskModal();
            });
        }
    });
    
    // Empty state create button
    const emptyStateBtn = document.getElementById('empty-state-create-btn');
    if (emptyStateBtn) {
        emptyStateBtn.addEventListener('click', () => {
            openTaskModal();
        });
    }
    
    // Close modal handlers
    if (modalClose) {
        modalClose.addEventListener('click', closeTaskModal);
    }
    if (modalCancel) {
        modalCancel.addEventListener('click', closeTaskModal);
    }
    if (modalOverlay) {
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                closeTaskModal();
            }
        });
    }
    
    // Keyboard shortcut - ESC to close
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modalOverlay && modalOverlay.classList.contains('active')) {
            closeTaskModal();
        }
    });
    
    // Initialize filter tabs immediately
    setupFilterTabs();
    console.log('‚úÖ Basic UI initialized (filter tabs, modals, buttons)');
    
    // Now wait for advanced modules (with timeout)
    const modulesLoaded = await waitForModules();
    
    if (modulesLoaded) {
        console.log('‚úÖ All CROWN‚Å¥.5 modules loaded');
    } else {
        console.warn('‚ö†Ô∏è Some modules failed to load - basic features still work');
    }
    
    // Initialize PredictiveEngine if available
    if (window.predictiveEngine) {
        await window.predictiveEngine.init();
        console.log('ü§ñ PredictiveEngine initialized');
    } else {
        console.warn('‚ö†Ô∏è PredictiveEngine not available');
    }
    
    // Initialize task editing modules if available
    if (window.TaskInlineEditing && window.optimisticUI) {
        window.taskInlineEditing = new window.TaskInlineEditing(window.optimisticUI);
        console.log('‚úèÔ∏è Inline editing initialized');
    } else {
        console.warn('‚ö†Ô∏è Inline editing not available');
    }
    
    if (window.TaskActionsMenu && window.optimisticUI) {
        window.taskActionsMenu = new window.TaskActionsMenu(window.optimisticUI);
        console.log('üéØ Task actions menu initialized');
    } else {
        console.warn('‚ö†Ô∏è Task actions menu not available');
    }
    
    if (window.TaskBulkOperations && window.optimisticUI) {
        window.taskBulkOperations = new window.TaskBulkOperations(window.optimisticUI);
        console.log('‚òëÔ∏è Bulk operations initialized');
    } else {
        console.warn('‚ö†Ô∏è Bulk operations not available');
    }
    
    if (window.TaskDragDrop && window.optimisticUI) {
        window.taskDragDrop = new window.TaskDragDrop(window.optimisticUI);
        console.log('üîÑ Drag-drop reordering initialized');
    } else {
        console.warn('‚ö†Ô∏è Drag-drop reordering not available');
    }
    
    if (window.TaskProposalUI && window.optimisticUI) {
        window.taskProposalUI = new window.TaskProposalUI(window.optimisticUI);
        console.log('‚ú® AI proposal UI initialized');
    } else {
        console.warn('‚ö†Ô∏è AI proposal UI not available');
    }
    
    // Initialize cache-first bootstrap
    if (window.taskBootstrap) {
        try {
            const startTime = performance.now();
            await window.taskBootstrap.bootstrap();
            const bootstrapTime = performance.now() - startTime;
            console.log(`‚ö° Bootstrap completed in ${bootstrapTime.toFixed(2)}ms`);
            
            // Log performance metrics
            if (bootstrapTime < 200) {
                console.log('üéØ CROWN‚Å¥.5 Target Met: <200ms first paint');
            } else {
                console.warn(`‚ö†Ô∏è Bootstrap slower than target: ${bootstrapTime.toFixed(2)}ms > 200ms`);
            }
        } catch (error) {
            console.error('‚ùå Bootstrap failed:', error);
        }
    } else {
        console.warn('‚ö†Ô∏è TaskBootstrap not available - page may have limited functionality');
    }
    
    // CROWN‚Å¥.5: Error state retry button
    const retryBtn = document.getElementById('error-state-retry-btn');
    if (retryBtn) {
        retryBtn.addEventListener('click', async () => {
            console.log('üîÑ Retry button clicked');
            retryBtn.disabled = true;
            retryBtn.textContent = 'Retrying...';
            
            try {
                if (window.taskBootstrap) {
                    await window.taskBootstrap.retryBootstrap();
                }
            } finally {
                retryBtn.disabled = false;
                retryBtn.innerHTML = `
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                    </svg>
                    Retry
                `;
            }
        });
    }
    
    // CROWN‚Å¥.5: Error state clear cache button
    const clearCacheBtn = document.getElementById('error-state-clear-cache-btn');
    if (clearCacheBtn) {
        clearCacheBtn.addEventListener('click', async () => {
            console.log('üóëÔ∏è Clear cache button clicked');
            clearCacheBtn.disabled = true;
            clearCacheBtn.textContent = 'Clearing...';
            
            try {
                if (window.taskCache) {
                    await window.taskCache.clear();
                    console.log('‚úÖ Cache cleared successfully');
                }
                
                // Show toast if available
                if (window.showToast) {
                    window.showToast('Cache cleared. Reloading...', 'success');
                }
                
                // Reload page after short delay
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
            } catch (error) {
                console.error('‚ùå Failed to clear cache:', error);
                if (window.showToast) {
                    window.showToast('Failed to clear cache', 'error');
                }
                clearCacheBtn.disabled = false;
                clearCacheBtn.textContent = 'Clear Cache';
            }
        });
    }
    
    // CROWN‚Å¥.5 Predictive suggestions on task title/description input
    let predictionDebounceTimer = null;
    const titleInput = document.getElementById('task-title');
    const descInput = document.getElementById('task-description');
    const predictionBanner = document.getElementById('ai-prediction-banner');
    const predictionContent = document.getElementById('ai-prediction-content');
    const prioritySelect = document.getElementById('task-priority');
    const dueDateInput = document.getElementById('task-due-date');
    
    async function showPredictions() {
        const title = titleInput.value.trim();
        const description = descInput.value.trim();
        
        if (!title || !window.predictiveEngine) {
            predictionBanner.style.display = 'none';
            return;
        }
        
        const predictions = await window.predictiveEngine.predict({ title, description });
        console.log('ü§ñ Predictive suggestions:', predictions);
        
        // Render predictions in banner
        if (predictions && (predictions.priority || predictions.dueDate || predictions.labels?.length)) {
            let html = '<div>';
            
            if (predictions.priority) {
                const confidence = Math.round((predictions.priority_confidence || 0.7) * 100);
                html += `<div style="margin-bottom: 6px;">
                    üìä <strong>Priority:</strong> ${predictions.priority.toUpperCase()} 
                    <span style="opacity: 0.8; font-size: 12px;">(${confidence}% confident)</span>
                    <button onclick="document.getElementById('task-priority').value='${predictions.priority}'; return false;" 
                            style="margin-left: 8px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Apply
                    </button>
                </div>`;
            }
            
            if (predictions.dueDate) {
                const confidence = Math.round((predictions.due_date_confidence || 0.7) * 100);
                const dateStr = new Date(predictions.dueDate).toLocaleDateString();
                html += `<div style="margin-bottom: 6px;">
                    üìÖ <strong>Due Date:</strong> ${dateStr} 
                    <span style="opacity: 0.8; font-size: 12px;">(${confidence}% confident)</span>
                    <button onclick="document.getElementById('task-due-date').value='${predictions.dueDate}'; return false;" 
                            style="margin-left: 8px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Apply
                    </button>
                </div>`;
            }
            
            if (predictions.labels?.length) {
                html += `<div>üè∑Ô∏è <strong>Suggested Labels:</strong> ${predictions.labels.join(', ')}</div>`;
            }
            
            if (predictions.reasoning) {
                html += `<div style="margin-top: 8px; opacity: 0.85; font-size: 12px; font-style: italic;">${predictions.reasoning}</div>`;
            }
            
            html += '</div>';
            predictionContent.innerHTML = html;
            predictionBanner.style.display = 'block';
            
            // Telemetry for predictions shown
            if (window.CROWNTelemetry && window.CROWNTelemetry.recordMetric) {
                window.CROWNTelemetry.recordMetric('prediction_shown_in_ui', 1);
                window.CROWNTelemetry.recordMetric('prediction_confidence_priority', predictions.priority_confidence || 0);
                window.CROWNTelemetry.recordMetric('prediction_confidence_due_date', predictions.due_date_confidence || 0);
            }
        } else {
            predictionBanner.style.display = 'none';
        }
    }
    
    // Debounced prediction on input
    [titleInput, descInput].forEach(input => {
        if (input) {
            input.addEventListener('input', () => {
                clearTimeout(predictionDebounceTimer);
                predictionDebounceTimer = setTimeout(showPredictions, 500);
            });
        }
    });
    
    // Handle form submission
    taskForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const title = document.getElementById('task-title').value.trim();
        const description = document.getElementById('task-description').value.trim();
        const priority = document.getElementById('task-priority').value;
        const dueDate = document.getElementById('task-due-date').value;
        const assignee = document.getElementById('task-assignee').value.trim();
        
        if (!title) {
            alert('Please enter a task title');
            return;
        }
        
        try {
            const submitBtn = document.getElementById('task-form-submit');
            submitBtn.disabled = true;
            submitBtn.textContent = 'Creating...';
            
            await window.optimisticUI.createTask({
                title: title,
                description: description || null,
                status: 'todo',
                priority: priority,
                due_date: dueDate || null,
                assignee: assignee || null
            });
            
            console.log('‚úÖ Task created');
            closeTaskModal();
            
            // Reset button
            submitBtn.disabled = false;
            submitBtn.innerHTML = `
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display: inline-block; margin-right: 8px;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                </svg>
                Create Task
            `;
        } catch (error) {
            console.error('‚ùå Failed to create task:', error);
            alert('Failed to create task. Please try again.');
            
            // Reset button
            const submitBtn = document.getElementById('task-form-submit');
            submitBtn.disabled = false;
            submitBtn.innerHTML = `
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display: inline-block; margin-right: 8px;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                </svg>
                Create Task
            `;
        }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // REMOVED: Duplicate checkbox handler
    // The CROWN‚Å¥.5 centralized handler (line 3066) handles checkboxes globally
    // with proper selection mode support. This duplicate handler was causing 
    // double-toggle bug (todo‚Üícompleted‚Üítodo instantly).
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Wire up delete buttons (using event delegation)
    const tasksListContainer = document.getElementById('tasks-list-container');
    if (tasksListContainer) {
        // Wire up delete buttons (using event delegation)
        tasksListContainer.addEventListener('click', async (e) => {
            const deleteBtn = e.target.closest('.task-delete-btn');
            if (deleteBtn) {
                const taskCard = deleteBtn.closest('.task-card');
                const taskId = taskCard.dataset.taskId;
                const taskTitle = taskCard.querySelector('.task-title').textContent;
                
                if (confirm(`Are you sure you want to delete "${taskTitle}"?`)) {
                    console.log(`üóëÔ∏è Deleting task ${taskId}`);
                    
                    try {
                        await window.optimisticUI.deleteTask(taskId);
                        console.log('‚úÖ Task deleted');
                    } catch (error) {
                        console.error('‚ùå Failed to delete task:', error);
                        alert('Failed to delete task. Please try again.');
                    }
                }
                return;
            }
            
            // Wire up label remove buttons (using event delegation)
            const labelRemoveBtn = e.target.closest('.label-remove-btn');
            if (labelRemoveBtn) {
                e.stopPropagation();
                const taskId = labelRemoveBtn.dataset.taskId;
                const label = labelRemoveBtn.dataset.label;
                
                console.log(`üè∑Ô∏è Removing label "${label}" from task ${taskId}`);
                
                try {
                    await window.optimisticUI.removeLabel(taskId, label);
                    console.log('‚úÖ Label removed');
                } catch (error) {
                    console.error('‚ùå Failed to remove label:', error);
                    alert('Failed to remove label. Please try again.');
                }
                return;
            }
            
            // Wire up label add buttons (using event delegation)
            const labelAddBtn = e.target.closest('.label-add-btn');
            if (labelAddBtn) {
                e.stopPropagation();
                const taskId = labelAddBtn.dataset.taskId;
                
                const label = prompt('Enter label name:');
                if (label && label.trim()) {
                    const trimmedLabel = label.trim();
                    console.log(`üè∑Ô∏è Adding label "${trimmedLabel}" to task ${taskId}`);
                    
                    try {
                        await window.optimisticUI.addLabel(taskId, trimmedLabel);
                        console.log('‚úÖ Label added');
                    } catch (error) {
                        console.error('‚ùå Failed to add label:', error);
                        alert('Failed to add label. Please try again.');
                    }
                }
                return;
            }
            
            // Wire up transcript link tracking (using event delegation)
            const transcriptLink = e.target.closest('.transcript-link-badge');
            if (transcriptLink) {
                const taskId = transcriptLink.dataset.taskId;
                
                // Track the jump-to-transcript event
                console.log(`üîó Jumping to transcript from task ${taskId}`);
                
                // Send event to server for tracking (non-blocking)
                fetch(`/api/tasks/${taskId}/track-transcript-jump`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin'
                }).catch(error => {
                    console.warn('Failed to track transcript jump:', error);
                });
                
                // Let the link navigate naturally (don't preventDefault)
                return;
            }
            
            // Wire up merge buttons (using event delegation)
            const mergeBtn = e.target.closest('.task-merge-btn');
            if (mergeBtn) {
                e.stopPropagation();
                const taskCard = mergeBtn.closest('.task-card');
                const taskId = taskCard.dataset.taskId;
                const taskTitle = taskCard.querySelector('.task-title').textContent;
                
                // Store task ID for merge modal
                window._mergeTargetTaskId = taskId;
                
                // Update modal title
                const mergeTitle = document.getElementById('merge-task-title');
                if (mergeTitle) {
                    mergeTitle.textContent = `Select a task to merge into "${taskTitle}":`;
                }
                
                // Populate merge task list with all other tasks
                const mergeTaskList = document.getElementById('merge-task-list');
                if (mergeTaskList) {
                    mergeTaskList.innerHTML = '';
                    
                    // Get all task cards except the current one
                    const allTaskCards = document.querySelectorAll('.task-card');
                    const otherTasks = Array.from(allTaskCards).filter(card => card.dataset.taskId !== taskId);
                    
                    if (otherTasks.length === 0) {
                        mergeTaskList.innerHTML = '<p class="text-secondary">No other tasks available to merge with.</p>';
                    } else {
                        otherTasks.forEach(card => {
                            const otherTaskId = card.dataset.taskId;
                            const otherTaskTitle = card.querySelector('.task-title').textContent;
                            const otherTaskPriority = card.dataset.priority || 'medium';
                            const otherTaskStatus = card.dataset.status || 'pending';
                            
                            const optionHTML = `
                                <div class="merge-task-option" data-task-id="${otherTaskId}">
                                    <div class="merge-task-option-title">${otherTaskTitle}</div>
                                    <div class="merge-task-option-meta">
                                        <span>Priority: ${otherTaskPriority}</span>
                                        <span>Status: ${otherTaskStatus}</span>
                                    </div>
                                </div>
                            `;
                            mergeTaskList.insertAdjacentHTML('beforeend', optionHTML);
                        });
                    }
                }
                
                // Show merge modal
                const mergeModal = document.getElementById('merge-modal-overlay');
                if (mergeModal) {
                    mergeModal.style.display = 'flex';
                }
                return;
            }
            
            // Wire up snooze buttons (using event delegation)
            const snoozeBtn = e.target.closest('.task-snooze-btn');
            if (snoozeBtn) {
                e.stopPropagation();
                const taskCard = snoozeBtn.closest('.task-card');
                const taskId = taskCard.dataset.taskId;
                const taskTitle = taskCard.querySelector('.task-title').textContent;
                
                // Store task ID for snooze modal
                window._snoozeTaskId = taskId;
                
                // Update modal title
                const snoozeTitle = document.getElementById('snooze-task-title');
                if (snoozeTitle) {
                    snoozeTitle.textContent = `Snooze "${taskTitle}" until...`;
                }
                
                // Show snooze modal
                const snoozeModal = document.getElementById('snooze-modal-overlay');
                if (snoozeModal) {
                    snoozeModal.style.display = 'flex';
                }
                return;
            }
        });
    }
    
    // Snooze modal handlers
    const snoozeModalOverlay = document.getElementById('snooze-modal-overlay');
    const snoozeModalClose = document.getElementById('snooze-modal-close');
    
    if (snoozeModalClose) {
        snoozeModalClose.addEventListener('click', () => {
            snoozeModalOverlay.style.display = 'none';
        });
    }
    
    if (snoozeModalOverlay) {
        snoozeModalOverlay.addEventListener('click', (e) => {
            if (e.target === snoozeModalOverlay) {
                snoozeModalOverlay.style.display = 'none';
            }
        });
        
        // Wire up snooze duration buttons
        const snoozeOptions = document.querySelectorAll('.snooze-option-btn');
        snoozeOptions.forEach(btn => {
            btn.addEventListener('click', async () => {
                const duration = btn.dataset.duration;
                const taskId = window._snoozeTaskId;
                
                if (!taskId) return;
                
                // Calculate snoozed_until timestamp
                const now = new Date();
                let snoozedUntil;
                
                switch (duration) {
                    case '1h':
                        snoozedUntil = new Date(now.getTime() + 60 * 60 * 1000);
                        break;
                    case '4h':
                        snoozedUntil = new Date(now.getTime() + 4 * 60 * 60 * 1000);
                        break;
                    case 'tomorrow':
                        snoozedUntil = new Date(now);
                        snoozedUntil.setDate(snoozedUntil.getDate() + 1);
                        snoozedUntil.setHours(9, 0, 0, 0);
                        break;
                    case '1w':
                        snoozedUntil = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
                        break;
                    default:
                        return;
                }
                
                console.log(`‚è∞ Snoozing task ${taskId} until ${snoozedUntil}`);
                
                try {
                    await window.optimisticUI.snoozeTask(taskId, snoozedUntil);
                    console.log('‚úÖ Task snoozed');
                    snoozeModalOverlay.style.display = 'none';
                    
                    if (window.showToast) {
                        window.showToast('Task snoozed successfully', 'success');
                    }
                } catch (error) {
                    console.error('‚ùå Failed to snooze task:', error);
                    alert('Failed to snooze task. Please try again.');
                }
            });
        });
    }
    
    // Merge modal handlers
    const mergeModalOverlay = document.getElementById('merge-modal-overlay');
    const mergeModalClose = document.getElementById('merge-modal-close');
    
    if (mergeModalClose) {
        mergeModalClose.addEventListener('click', () => {
            mergeModalOverlay.style.display = 'none';
        });
    }
    
    if (mergeModalOverlay) {
        mergeModalOverlay.addEventListener('click', (e) => {
            if (e.target === mergeModalOverlay) {
                mergeModalOverlay.style.display = 'none';
            }
        });
        
        // Wire up merge task option clicks (using event delegation)
        mergeModalOverlay.addEventListener('click', async (e) => {
            const mergeOption = e.target.closest('.merge-task-option');
            if (mergeOption) {
                const sourceTaskId = mergeOption.dataset.taskId;
                const targetTaskId = window._mergeTargetTaskId;
                
                if (!sourceTaskId || !targetTaskId) return;
                
                if (confirm('Are you sure you want to merge these tasks? This cannot be undone.')) {
                    console.log(`üîÄ Merging task ${sourceTaskId} into ${targetTaskId}`);
                    
                    try {
                        await window.optimisticUI.mergeTasks(sourceTaskId, targetTaskId);
                        console.log('‚úÖ Tasks merged');
                        mergeModalOverlay.style.display = 'none';
                        
                        if (window.showToast) {
                            window.showToast('Tasks merged successfully', 'success');
                        }
                    } catch (error) {
                        console.error('‚ùå Failed to merge tasks:', error);
                        alert('Failed to merge tasks. Please try again.');
                    }
                }
            }
        });
    }
    
    // Monitor online/offline status
    window.addEventListener('online', () => {
        console.log('üåê Back online - triggering sync');
        if (window.showToast) {
            window.showToast('Connection restored', 'info');
        }
    });
    
    window.addEventListener('offline', () => {
        console.log('üìµ Offline - operations will be queued');
        if (window.showToast) {
            window.showToast('Offline mode - changes will sync when online', 'warning');
        }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üéØ CROWN‚Å¥.5 Smart Selection System (Industry Best Practice 2025)
    // Global Selection Manager - accessible from clustering and main views
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    window.selectionManager = {
        selection: new Set(),
        active: false,
        indicator: null,
        lastSelectedIndex: -1,
        toolbar: document.getElementById('bulk-action-toolbar'),
        countElement: document.getElementById('bulk-selected-count'),
        
        isActive() {
            return this.active;
        },
        
        getSelection() {
            return Array.from(this.selection);
        },
        
        updateToolbar() {
            const count = this.selection.size;
            if (count > 0) {
                this.toolbar.style.display = 'flex';
                this.countElement.textContent = count;
            } else {
                this.toolbar.style.display = 'none';
            }
        },
        
        enter() {
            if (this.active) return;
            this.active = true;
            
            // Add visual indicator
            this.indicator = document.createElement('div');
            this.indicator.className = 'selection-mode-indicator';
            this.indicator.textContent = 'üìã Selection Mode';
            document.body.appendChild(this.indicator);
            
            // Add selection-mode class to all task cards
            this.restoreSelectionUI();
            
            console.log('üéØ Entered selection mode');
            
            // Haptic feedback on mobile
            if ('vibrate' in navigator) {
                navigator.vibrate(50);
            }
        },
        
        exit() {
            if (!this.active) return;
            this.active = false;
            
            // Remove indicator
            if (this.indicator) {
                this.indicator.remove();
                this.indicator = null;
            }
            
            // Remove selection-mode class
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('selection-mode');
                card.classList.remove('bulk-selected');
            });
            
            // Clear selection
            this.selection.clear();
            this.updateToolbar();
            this.lastSelectedIndex = -1;
            
            console.log('üéØ Exited selection mode');
        },
        
        toggle(taskCard) {
            const taskId = taskCard.dataset.taskId;
            
            if (this.selection.has(taskId)) {
                this.selection.delete(taskId);
                taskCard.classList.remove('bulk-selected');
            } else {
                this.selection.add(taskId);
                taskCard.classList.add('bulk-selected');
                
                // Haptic feedback
                if ('vibrate' in navigator) {
                    navigator.vibrate(10);
                }
            }
            
            this.updateToolbar();
        },
        
        // Restore selection UI after view changes (list ‚Üî cluster)
        restoreSelectionUI() {
            document.querySelectorAll('.task-card').forEach(card => {
                const taskId = card.dataset.taskId;
                
                if (this.active) {
                    card.classList.add('selection-mode');
                }
                
                if (this.selection.has(taskId)) {
                    card.classList.add('bulk-selected');
                }
            });
            
            console.log(`üîÑ Restored selection UI: ${this.selection.size} tasks selected`);
        }
    };
    
    // Backward compatibility aliases
    const bulkSelection = window.selectionManager.selection;
    const updateBulkToolbar = () => window.selectionManager.updateToolbar();
    const enterSelectionMode = () => window.selectionManager.enter();
    const exitSelectionMode = () => window.selectionManager.exit();
    const toggleTaskSelection = (taskCard) => window.selectionManager.toggle(taskCard);
    
    // Selection mode state getter (auto-synced with window.selectionManager.active)
    let selectionMode = false;
    Object.defineProperty(window, 'selectionMode', {
        get: () => window.selectionManager.active,
        configurable: true
    });
    
    // Last selected index for shift-click range selection
    let lastSelectedIndex = -1;
    
    // Restore selection UI after task list refreshes
    window.addEventListener('tasks:refresh-view', () => {
        setTimeout(() => {
            if (window.selectionManager) {
                window.selectionManager.restoreSelectionUI();
            }
        }, 100);
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚úèÔ∏è CROWN‚Å¥.5 Inline Title Editing (Event #6)
    // Debounced save (250ms), ESC cancel, Enter save, visual indicators
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let editingTitle = null;
    let originalTitleText = '';
    let saveDebounceTimer = null;
    const SAVE_DEBOUNCE_MS = 250;
    
    function makeTitleEditable(titleElement) {
        if (editingTitle === titleElement) return;
        
        // Cancel any existing edit
        if (editingTitle) {
            cancelTitleEdit();
        }
        
        editingTitle = titleElement;
        originalTitleText = titleElement.textContent.trim();
        
        // Replace h3 with input for cross-browser security (prevents HTML injection)
        const input = document.createElement('input');
        input.type = 'text';
        input.value = originalTitleText;
        input.className = 'task-title-input';
        input.style.cssText = titleElement.style.cssText;
        input.maxLength = 500;
        
        // Store reference to original element
        input.dataset.originalElement = 'true';
        titleElement.dataset.editing = 'true';
        titleElement.style.display = 'none';
        titleElement.parentNode.insertBefore(input, titleElement);
        
        input.focus();
        input.select();
        
        // Store the input reference
        editingTitle.inputElement = input;
        
        console.log('‚úèÔ∏è Started editing title');
    }
    
    function saveTitleEdit() {
        if (!editingTitle || !editingTitle.inputElement) return;
        
        // Cancel any pending debounce timer
        if (saveDebounceTimer) {
            clearTimeout(saveDebounceTimer);
            saveDebounceTimer = null;
        }
        
        const input = editingTitle.inputElement;
        const newTitle = input.value.trim().replace(/\s+/g, ' ');
        const taskCard = editingTitle.closest('.task-card');
        const taskId = taskCard?.dataset.taskId;
        
        if (!taskId || newTitle === originalTitleText) {
            cancelTitleEdit();
            return;
        }
        
        // Validate: no empty titles
        if (newTitle === '' || newTitle.length > 500) {
            cancelTitleEdit();
            if (window.showToast) {
                window.showToast('Title must be between 1-500 characters', 'error');
            }
            return;
        }
        
        const titleElement = editingTitle;
        
        // Optimistic UI: update immediately (<50ms CROWN‚Å¥.5 requirement)
        titleElement.textContent = newTitle;
        titleElement.style.display = '';
        input.remove();
        titleElement.classList.add('saving');
        
        console.log(`üíæ Saving title: "${newTitle}" for task ${taskId}`);
        
        // Send update to server
        fetch(`/api/tasks/${taskId}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                description: newTitle
            })
        })
        .then(response => {
            if (!response.ok) throw new Error('Failed to save');
            return response.json();
        })
        .then(data => {
            console.log('‚úÖ Title saved successfully');
            
            // Show saved indicator
            titleElement.classList.remove('saving');
            titleElement.classList.add('saved');
            
            // Remove saved indicator after 2s
            setTimeout(() => {
                titleElement.classList.remove('saved');
            }, 2000);
            
            originalTitleText = newTitle;
            delete titleElement.inputElement;
            delete titleElement.dataset.editing;
            editingTitle = null;
            
            // Broadcast to other tabs via WebSocket (CROWN‚Å¥.5 multi-tab sync)
            if (window.socket) {
                window.socket.emit('task:updated', {
                    task_id: taskId,
                    field: 'description',
                    value: newTitle
                });
            }
        })
        .catch(error => {
            console.error('‚ùå Failed to save title:', error);
            
            // Revert to original
            titleElement.textContent = originalTitleText;
            titleElement.style.display = '';
            if (input.parentNode) input.remove();
            titleElement.classList.remove('saving');
            delete titleElement.inputElement;
            delete titleElement.dataset.editing;
            editingTitle = null;
            
            if (window.showToast) {
                window.showToast('Failed to save title', 'error');
            }
        });
    }
    
    function cancelTitleEdit() {
        if (!editingTitle) return;
        
        // Cancel any pending save
        if (saveDebounceTimer) {
            clearTimeout(saveDebounceTimer);
            saveDebounceTimer = null;
        }
        
        // Remove input and restore original title
        if (editingTitle.inputElement && editingTitle.inputElement.parentNode) {
            editingTitle.inputElement.remove();
        }
        editingTitle.textContent = originalTitleText;
        editingTitle.style.display = '';
        editingTitle.classList.remove('saving', 'saved');
        delete editingTitle.inputElement;
        delete editingTitle.dataset.editing;
        editingTitle = null;
        
        console.log('‚ùå Cancelled title edit');
    }
    
    // Click on title to edit
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('task-title') && !window.selectionManager.isActive()) {
            e.stopPropagation();
            makeTitleEditable(e.target);
        } else if (e.target.classList.contains('task-title-input')) {
            // Clicking on input - do nothing (keep editing)
            e.stopPropagation();
        } else if (editingTitle && !e.target.closest('.task-title') && !e.target.classList.contains('task-title-input')) {
            // Click outside - save
            saveTitleEdit();
        }
    });
    
    // Handle keyboard shortcuts on input
    document.addEventListener('keydown', (e) => {
        if (!e.target.classList.contains('task-title-input')) return;
        
        if (e.key === 'Escape') {
            e.preventDefault();
            cancelTitleEdit();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            saveTitleEdit();
        }
    });
    
    // Debounced save on input
    document.addEventListener('input', (e) => {
        if (e.target.classList.contains('task-title-input')) {
            // Clear existing timer
            if (saveDebounceTimer) {
                clearTimeout(saveDebounceTimer);
            }
            
            // Set new timer
            saveDebounceTimer = setTimeout(() => {
                saveTitleEdit();
            }, SAVE_DEBOUNCE_MS);
        }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚úÖ CROWN‚Å¥.5 Centralized Checkbox Handler
    // Uses event delegation to work across all views without rebinding
    // Respects selection mode to prevent completion toggle during bulk select
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    document.addEventListener('change', async (e) => {
        if (!e.target.classList.contains('task-checkbox')) return;
        
        // If selection mode is active, checkboxes control selection, not completion
        if (window.selectionManager && window.selectionManager.isActive()) {
            e.preventDefault();
            const taskCard = e.target.closest('.task-card');
            if (taskCard) {
                window.selectionManager.toggle(taskCard);
            }
            return;
        }
        
        // Normal mode: toggle task completion
        const taskId = e.target.dataset.taskId;
        if (taskId && window.optimisticUI) {
            await window.optimisticUI.toggleTaskStatus(taskId);
        }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CROWN‚Å¥.5 Event #7-9: Inline Metadata Editing
    // Assignee, Due Date, Labels with optimistic UI and WebSocket sync
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let activeDropdown = null;
    let cachedUsers = null;
    
    // Fetch assignable users (cached)
    async function fetchAssignableUsers() {
        if (cachedUsers) return cachedUsers;
        
        try {
            const response = await fetch('/api/tasks/users');
            const data = await response.json();
            if (data.success) {
                cachedUsers = data.users;
                return cachedUsers;
            }
        } catch (error) {
            console.error('Failed to fetch users:', error);
        }
        return [];
    }
    
    // Close active dropdown
    function closeActiveDropdown() {
        if (activeDropdown) {
            activeDropdown.remove();
            activeDropdown = null;
        }
    }
    
    // Show assignee dropdown
    async function showAssigneeDropdown(taskCard, targetElement) {
        closeActiveDropdown();
        
        const users = await fetchAssignableUsers();
        const taskId = taskCard.dataset.taskId;
        const currentAssigneeId = taskCard.dataset.assignedTo;
        
        // Create dropdown
        const dropdown = document.createElement('div');
        dropdown.className = 'task-assignee-dropdown';
        
        // Add "Unassigned" option
        const unassignedOption = document.createElement('div');
        unassignedOption.className = 'assignee-option';
        unassignedOption.textContent = 'üë§ Unassigned';
        unassignedOption.onclick = () => updateTaskAssignee(taskId, null, taskCard);
        dropdown.appendChild(unassignedOption);
        
        // Add user options
        users.forEach(user => {
            const option = document.createElement('div');
            option.className = 'assignee-option';
            option.textContent = `üë§ ${user.name}`;
            if (user.id == currentAssigneeId) {
                option.style.background = 'rgba(99, 102, 241, 0.2)';
            }
            option.onclick = () => updateTaskAssignee(taskId, user.id, taskCard, user.name);
            dropdown.appendChild(option);
        });
        
        // Position dropdown
        const rect = targetElement.getBoundingClientRect();
        dropdown.style.position = 'fixed';
        dropdown.style.top = `${rect.bottom + 4}px`;
        dropdown.style.left = `${rect.left}px`;
        
        document.body.appendChild(dropdown);
        activeDropdown = dropdown;
    }
    
    // Update task assignee
    async function updateTaskAssignee(taskId, userId, taskCard, userName) {
        closeActiveDropdown();
        
        // Optimistic UI
        const assigneeElement = taskCard.querySelector('.task-assignee');
        const originalHTML = assigneeElement.innerHTML;
        
        if (userId) {
            assigneeElement.innerHTML = `<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg> ${userName}`;
            taskCard.dataset.assignedTo = userId;
        } else {
            assigneeElement.innerHTML = `<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg> Unassigned`;
            taskCard.dataset.assignedTo = '';
        }
        
        try {
            const response = await fetch(`/api/tasks/${taskId}`, {
                method: 'PATCH',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({assigned_to_id: userId})
            });
            
            if (!response.ok) throw new Error('Failed to update');
            
            // WebSocket broadcast
            if (window.socket) {
                window.socket.emit('task:updated', {
                    task_id: taskId,
                    field: 'assigned_to_id',
                    value: userId
                });
            }
            
            console.log(`‚úÖ Task ${taskId} assigned to ${userName || 'Unassigned'}`);
        } catch (error) {
            console.error('Failed to update assignee:', error);
            assigneeElement.innerHTML = originalHTML;
            if (window.showToast) {
                window.showToast('Failed to update assignee', 'error');
            }
        }
    }
    
    // Show due date picker
    function showDueDatePicker(taskCard, targetElement) {
        closeActiveDropdown();
        
        const taskId = taskCard.dataset.taskId;
        
        // Create picker
        const picker = document.createElement('div');
        picker.className = 'task-due-date-picker';
        
        // Add shortcuts
        const shortcuts = document.createElement('div');
        shortcuts.className = 'date-shortcuts';
        
        const addShortcut = (label, days) => {
            const btn = document.createElement('button');
            btn.className = 'date-shortcut-btn';
            btn.textContent = label;
            btn.onclick = () => {
                const date = new Date();
                date.setDate(date.getDate() + days);
                updateTaskDueDate(taskId, date.toISOString().split('T')[0], taskCard, label);
            };
            shortcuts.appendChild(btn);
        };
        
        addShortcut('üìÖ Today', 0);
        addShortcut('üìÖ Tomorrow', 1);
        addShortcut('üìÖ Next Week', 7);
        addShortcut('üóëÔ∏è Clear due date', null);
        
        picker.appendChild(shortcuts);
        
        // Add date input
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.className = 'label-input';
        dateInput.value = taskCard.dataset.dueDate || '';
        dateInput.onchange = (e) => {
            updateTaskDueDate(taskId, e.target.value, taskCard, e.target.value);
        };
        picker.appendChild(dateInput);
        
        // Position picker
        const rect = targetElement.getBoundingClientRect();
        picker.style.position = 'fixed';
        picker.style.top = `${rect.bottom + 4}px`;
        picker.style.left = `${rect.left}px`;
        
        document.body.appendChild(picker);
        activeDropdown = picker;
    }
    
    // Update task due date
    async function updateTaskDueDate(taskId, dueDate, taskCard, displayText) {
        closeActiveDropdown();
        
        // Optimistic UI
        const dueDateElement = taskCard.querySelector('.task-due-date');
        const originalHTML = dueDateElement.innerHTML;
        
        if (dueDate && dueDate !== 'null') {
            const date = new Date(dueDate);
            const formatted = date.toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
            dueDateElement.innerHTML = `<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg> ${formatted}`;
            taskCard.dataset.dueDate = dueDate;
        } else {
            dueDateElement.innerHTML = `<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg> No due date`;
            taskCard.dataset.dueDate = '';
        }
        
        try {
            const response = await fetch(`/api/tasks/${taskId}`, {
                method: 'PATCH',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({due_date: dueDate || null})
            });
            
            if (!response.ok) throw new Error('Failed to update');
            
            // WebSocket broadcast
            if (window.socket) {
                window.socket.emit('task:updated', {
                    task_id: taskId,
                    field: 'due_date',
                    value: dueDate
                });
            }
            
            console.log(`‚úÖ Task ${taskId} due date set to ${dueDate || 'none'}`);
        } catch (error) {
            console.error('Failed to update due date:', error);
            dueDateElement.innerHTML = originalHTML;
            if (window.showToast) {
                window.showToast('Failed to update due date', 'error');
            }
        }
    }
    
    // Show labels editor
    function showLabelsEditor(taskCard, targetElement) {
        closeActiveDropdown();
        
        const taskId = taskCard.dataset.taskId;
        const currentLabels = JSON.parse(taskCard.dataset.labels || '[]');
        
        // Create editor
        const editor = document.createElement('div');
        editor.className = 'task-labels-editor';
        
        // Add input container
        const inputContainer = document.createElement('div');
        inputContainer.className = 'label-input-container';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'label-input';
        input.placeholder = 'Type to add label...';
        input.onkeydown = (e) => {
            if (e.key === 'Enter' && input.value.trim()) {
                e.preventDefault();
                const newLabels = [...currentLabels, input.value.trim()];
                updateTaskLabels(taskId, newLabels, taskCard);
                input.value = '';
            }
        };
        inputContainer.appendChild(input);
        editor.appendChild(inputContainer);
        
        // Show current labels
        if (currentLabels.length > 0) {
            const currentLabelsDiv = document.createElement('div');
            currentLabelsDiv.className = 'label-suggestions';
            currentLabelsDiv.innerHTML = '<small style="color: var(--color-text-secondary); width: 100%;">Current labels (click to remove):</small>';
            currentLabels.forEach(label => {
                const labelSpan = document.createElement('span');
                labelSpan.className = 'label-suggestion';
                labelSpan.textContent = label;
                labelSpan.onclick = () => {
                    const newLabels = currentLabels.filter(l => l !== label);
                    updateTaskLabels(taskId, newLabels, taskCard);
                };
                currentLabelsDiv.appendChild(labelSpan);
            });
            editor.appendChild(currentLabelsDiv);
        }
        
        // Position editor
        const rect = targetElement.getBoundingClientRect();
        editor.style.position = 'fixed';
        editor.style.top = `${rect.bottom + 4}px`;
        editor.style.left = `${rect.left}px`;
        
        document.body.appendChild(editor);
        activeDropdown = editor;
        input.focus();
    }
    
    // Update task labels
    async function updateTaskLabels(taskId, labels, taskCard) {
        closeActiveDropdown();
        
        // Optimistic UI
        const labelsContainer = taskCard.querySelector('[data-field="labels"]');
        const originalHTML = labelsContainer.outerHTML;
        
        if (labels && labels.length > 0) {
            labelsContainer.className = 'task-labels';
            labelsContainer.innerHTML = labels.map(label => 
                `<span class="task-label">${label}</span>`
            ).join('');
        } else {
            labelsContainer.className = 'task-labels-empty';
            labelsContainer.innerHTML = `<svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24"><path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/></svg> Add labels`;
        }
        
        taskCard.dataset.labels = JSON.stringify(labels);
        
        try {
            const response = await fetch(`/api/tasks/${taskId}`, {
                method: 'PATCH',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({labels: labels})
            });
            
            if (!response.ok) throw new Error('Failed to update');
            
            // WebSocket broadcast
            if (window.socket) {
                window.socket.emit('task:updated', {
                    task_id: taskId,
                    field: 'labels',
                    value: labels
                });
            }
            
            console.log(`‚úÖ Task ${taskId} labels updated`);
        } catch (error) {
            console.error('Failed to update labels:', error);
            labelsContainer.outerHTML = originalHTML;
            if (window.showToast) {
                window.showToast('Failed to update labels', 'error');
            }
        }
    }
    
    // Click handlers for metadata fields
    document.addEventListener('click', (e) => {
        const metadataField = e.target.closest('[data-field]');
        if (!metadataField) {
            // Click outside - close dropdown
            if (activeDropdown && !e.target.closest('.task-assignee-dropdown, .task-due-date-picker, .task-labels-editor')) {
                closeActiveDropdown();
            }
            return;
        }
        
        if (window.selectionManager && window.selectionManager.isActive()) return;
        
        const taskCard = metadataField.closest('.task-card');
        if (!taskCard) return;
        
        const field = metadataField.dataset.field;
        
        if (field === 'assignee') {
            showAssigneeDropdown(taskCard, metadataField);
        } else if (field === 'due_date') {
            showDueDatePicker(taskCard, metadataField);
        } else if (field === 'labels') {
            showLabelsEditor(taskCard, metadataField);
        }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CROWN‚Å¥.5 Event #11: Jump to Transcript
    // Navigate to session transcript and highlight task origin
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    document.addEventListener('click', (e) => {
        const jumpBtn = e.target.closest('.jump-to-transcript');
        if (!jumpBtn) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        const sessionId = jumpBtn.dataset.sessionId;
        const transcriptSpan = JSON.parse(jumpBtn.dataset.transcriptSpan || '{}');
        
        if (!sessionId) {
            console.error('No session ID found for jump to transcript');
            return;
        }
        
        // Navigate to session transcript with highlight parameters
        const highlightParams = new URLSearchParams({
            highlight_start: transcriptSpan.start_ms || 0,
            highlight_end: transcriptSpan.end_ms || 0,
            segment_ids: JSON.stringify(transcriptSpan.segment_ids || [])
        });
        
        const url = `/sessions/${sessionId}?${highlightParams.toString()}`;
        
        console.log(`üéØ Jumping to transcript: ${url}`);
        window.location.href = url;
    });
    
    // Long-press for mobile selection mode
    let longPressTimer = null;
    const LONG_PRESS_DURATION = 400;
    
    document.addEventListener('touchstart', (e) => {
        const taskCard = e.target.closest('.task-card');
        if (!taskCard || e.target.closest('.task-checkbox')) return;
        
        longPressTimer = setTimeout(() => {
            enterSelectionMode();
            toggleTaskSelection(taskCard);
        }, LONG_PRESS_DURATION);
    });
    
    document.addEventListener('touchend', () => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    });
    
    document.addEventListener('touchmove', () => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    });
    
    // Click handler for desktop + mobile
    document.addEventListener('click', (e) => {
        const taskCard = e.target.closest('.task-card');
        
        // Ignore clicks on checkbox or inside title
        if (e.target.closest('.task-checkbox') || e.target.closest('.task-title')) {
            return;
        }
        
        if (taskCard) {
            const isMetaKey = e.metaKey || e.ctrlKey; // Cmd/Ctrl
            const isShiftKey = e.shiftKey;
            
            // Cmd/Ctrl+Click: Toggle selection (enter mode if needed)
            if (isMetaKey) {
                if (!selectionMode) enterSelectionMode();
                toggleTaskSelection(taskCard);
                lastSelectedIndex = Array.from(document.querySelectorAll('.task-card')).indexOf(taskCard);
                return;
            }
            
            // Shift+Click: Range selection
            if (isShiftKey && lastSelectedIndex >= 0) {
                if (!selectionMode) enterSelectionMode();
                
                const allCards = Array.from(document.querySelectorAll('.task-card'));
                const currentIndex = allCards.indexOf(taskCard);
                const start = Math.min(lastSelectedIndex, currentIndex);
                const end = Math.max(lastSelectedIndex, currentIndex);
                
                // Select range
                for (let i = start; i <= end; i++) {
                    const card = allCards[i];
                    const taskId = card.dataset.taskId;
                    bulkSelection.add(taskId);
                    card.classList.add('bulk-selected');
                }
                
                updateBulkToolbar();
                return;
            }
            
            // Regular click in selection mode: toggle
            if (selectionMode) {
                toggleTaskSelection(taskCard);
                lastSelectedIndex = Array.from(document.querySelectorAll('.task-card')).indexOf(taskCard);
            }
        }
    });
    
    // Bulk cancel button - exits selection mode
    const bulkCancelBtn = document.getElementById('bulk-cancel-btn');
    if (bulkCancelBtn) {
        bulkCancelBtn.addEventListener('click', () => {
            exitSelectionMode();
        });
    }
    
    // ESC key to exit selection mode
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && selectionMode) {
            exitSelectionMode();
        }
    });
    
    // Bulk complete button
    const bulkCompleteBtn = document.getElementById('bulk-complete-btn');
    if (bulkCompleteBtn) {
        bulkCompleteBtn.addEventListener('click', async () => {
            const taskIds = Array.from(bulkSelection);
            if (taskIds.length === 0) return;
            
            console.log(`‚úÖ Bulk completing ${taskIds.length} tasks`);
            console.log('üìã Task IDs to complete:', taskIds);
            
            try {
                // Optimistic UI: mark all as completed
                taskIds.forEach(taskId => {
                    const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
                    if (taskCard) {
                        taskCard.classList.add('completed');
                        const checkbox = taskCard.querySelector('.task-checkbox');
                        if (checkbox) checkbox.checked = true;
                    }
                });
                
                // Send bulk update to server
                const response = await fetch('/api/tasks/bulk/complete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ task_ids: taskIds })
                });
                
                console.log('üì° Bulk complete response:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok,
                    headers: Object.fromEntries(response.headers.entries())
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå Server returned error:', errorText);
                    
                    // Handle authentication errors
                    if (response.status === 401) {
                        alert('Your session has expired. Please log in again.');
                        window.location.href = '/login';
                        return;
                    }
                    
                    throw new Error(`Bulk complete failed: ${response.status} ${response.statusText} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Bulk complete successful:', result);
                
                // CRITICAL FIX: Update IndexedDB cache for all completed tasks
                if (window.taskCache) {
                    for (const taskId of taskIds) {
                        await window.taskCache.updateTaskStatus(taskId, 'completed');
                    }
                    console.log(`üíæ Updated cache for ${taskIds.length} tasks ‚Üí completed`);
                }
                
                // Re-apply active filter to hide completed tasks from Pending view
                const viewState = await window.taskCache?.getViewState();
                const activeFilter = viewState?.activeFilter || 'all';
                
                if (activeFilter === 'pending') {
                    console.log('üîÑ Re-applying Pending filter to hide completed tasks');
                    // Fetch all tasks and filter
                    const allTasks = await window.taskCache.getAllTasks();
                    const pendingTasks = allTasks.filter(t => t.status === 'todo' || t.status === 'in_progress');
                    
                    // Re-render filtered view
                    if (window.taskBootstrap) {
                        await window.taskBootstrap.renderTasks(pendingTasks);
                        await window.taskBootstrap.updateCounters(pendingTasks);
                    }
                }
                
                // Exit selection mode
                exitSelectionMode();
                
                if (window.showToast) {
                    window.showToast(`${taskIds.length} tasks completed`, 'success');
                }
                
            } catch (error) {
                console.error('‚ùå Bulk complete failed:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                
                // Rollback optimistic UI
                taskIds.forEach(taskId => {
                    const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
                    if (taskCard) {
                        taskCard.classList.remove('completed');
                        const checkbox = taskCard.querySelector('.task-checkbox');
                        if (checkbox) checkbox.checked = false;
                    }
                });
                
                alert('Failed to complete tasks. Please try again.');
            }
        });
    }
    
    // Bulk delete button
    const bulkDeleteBtn = document.getElementById('bulk-delete-btn');
    if (bulkDeleteBtn) {
        bulkDeleteBtn.addEventListener('click', async () => {
            const taskIds = Array.from(bulkSelection);
            if (taskIds.length === 0) return;
            
            if (!confirm(`Are you sure you want to delete ${taskIds.length} tasks? This cannot be undone.`)) {
                return;
            }
            
            console.log(`üóëÔ∏è Bulk deleting ${taskIds.length} tasks`);
            console.log('üìã Task IDs to delete:', taskIds);
            
            // Save original cards for rollback
            const savedCards = new Map();
            
            try {
                // Optimistic UI: remove all cards
                taskIds.forEach(taskId => {
                    const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
                    if (taskCard) {
                        savedCards.set(taskId, taskCard.cloneNode(true));
                        taskCard.style.animation = 'fadeOut 0.3s ease-out';
                        setTimeout(() => taskCard.remove(), 300);
                    }
                });
                
                // Send bulk delete to server
                const response = await fetch('/api/tasks/bulk/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ task_ids: taskIds })
                });
                
                console.log('üì° Bulk delete response:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok,
                    headers: Object.fromEntries(response.headers.entries())
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå Server returned error:', errorText);
                    
                    // Handle authentication errors
                    if (response.status === 401) {
                        alert('Your session has expired. Please log in again.');
                        window.location.href = '/login';
                        return;
                    }
                    
                    throw new Error(`Bulk delete failed: ${response.status} ${response.statusText} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Bulk delete successful:', result);
                
                // Exit selection mode
                exitSelectionMode();
                
                if (window.showToast) {
                    window.showToast(`${taskIds.length} tasks deleted`, 'success');
                }
                
            } catch (error) {
                console.error('‚ùå Bulk delete failed:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                
                // Rollback: restore cards
                const container = document.getElementById('tasks-list-container');
                savedCards.forEach((card, taskId) => {
                    container.appendChild(card);
                });
                
                const errorMsg = error.message || 'Failed to delete tasks. Please try again.';
                alert(errorMsg);
                
                if (window.showToast) {
                    window.showToast(errorMsg, 'error');
                }
            }
        });
    }
    
    // Bulk label button
    const bulkLabelBtn = document.getElementById('bulk-label-btn');
    if (bulkLabelBtn) {
        bulkLabelBtn.addEventListener('click', async () => {
            const taskIds = Array.from(bulkSelection);
            if (taskIds.length === 0) return;
            
            const label = prompt('Enter label to add to selected tasks:');
            if (!label || label.trim() === '') return;
            
            console.log(`üè∑Ô∏è Bulk adding label "${label}" to ${taskIds.length} tasks`);
            console.log('üìã Task IDs to label:', taskIds);
            
            try {
                // Optimistic UI: add label to all cards
                taskIds.forEach(taskId => {
                    const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
                    if (taskCard) {
                        const labelsContainer = taskCard.querySelector('.task-labels');
                        if (labelsContainer) {
                            const labelBadge = document.createElement('span');
                            labelBadge.className = 'label-badge';
                            labelBadge.innerHTML = `
                                ${label.trim()}
                                <button class="label-remove-btn" data-task-id="${taskId}" data-label="${label.trim()}">√ó</button>
                            `;
                            labelsContainer.appendChild(labelBadge);
                        }
                    }
                });
                
                // Send bulk label update to server
                const response = await fetch('/api/tasks/bulk/label', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        task_ids: taskIds,
                        label: label.trim()
                    })
                });
                
                console.log('üì° Bulk label response:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok,
                    headers: Object.fromEntries(response.headers.entries())
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå Server returned error:', errorText);
                    
                    // Handle authentication errors
                    if (response.status === 401) {
                        alert('Your session has expired. Please log in again.');
                        window.location.href = '/login';
                        return;
                    }
                    
                    throw new Error(`Bulk label failed: ${response.status} ${response.statusText} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Bulk label successful:', result);
                
                // Exit selection mode
                exitSelectionMode();
                
                if (window.showToast) {
                    window.showToast(`Label "${label}" added to ${taskIds.length} tasks`, 'success');
                }
                
            } catch (error) {
                console.error('‚ùå Bulk label failed:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                
                // Rollback: remove added labels
                taskIds.forEach(taskId => {
                    const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
                    if (taskCard) {
                        const labelsContainer = taskCard.querySelector('.task-labels');
                        if (labelsContainer) {
                            const addedLabel = labelsContainer.querySelector(`.label-badge:last-child`);
                            if (addedLabel) addedLabel.remove();
                        }
                    }
                });
                
                const errorMsg = error.message || 'Failed to add labels. Please try again.';
                alert(errorMsg);
                
                if (window.showToast) {
                    window.showToast(errorMsg, 'error');
                }
            }
        });
    }
    
    // Log system stats every 30 seconds
    setInterval(() => {
        const stats = {
            cache: window.taskCache.getStats(),
            virtualList: window.taskVirtualList.getStats(),
            online: navigator.onLine
        };
        console.log('üìä CROWN‚Å¥.5 Stats:', stats);
    }, 30000);
    
    // Add global cache clear function for debugging
    window.clearTaskCache = async function() {
        console.log('üßπ Clearing IndexedDB cache...');
        try {
            const request = indexedDB.deleteDatabase('MinaDB');
            request.onsuccess = () => {
                console.log('‚úÖ Cache cleared successfully! Reloading page...');
                setTimeout(() => window.location.reload(), 500);
            };
            request.onerror = () => {
                console.error('‚ùå Failed to clear cache');
            };
        } catch (error) {
            console.error('‚ùå Error clearing cache:', error);
        }
    };
    
    console.log('‚ú® CROWN‚Å¥.5 Tasks Page Ready');
    console.log('üí° Debug tip: Run clearTaskCache() to clear cache and reload');
})();
</script>
{% endblock %}
